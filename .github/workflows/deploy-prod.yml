name: Deploy Production

on:
  push:
    branches: ['main']

concurrency:
  group: deploy-production
  cancel-in-progress: true

env:
  COMPOSE_PROJECT_NAME: 10xcoder-prod
  APP_CONTAINER_NAME: 10xcoder_prod_app
  DB_CONTAINER_NAME: 10xcoder_prod_db
  REDIS_CONTAINER_NAME: 10xcoder_prod_redis
  NGINX_CONTAINER_NAME: 10xcoder_prod_nginx
  DB_VOLUME_NAME: postgres_prod_data
  REDIS_VOLUME_NAME: redis_prod_data
  NGINX_PORT: 80
  APP_PORT: 3000

jobs:
  # ==========================================================================
  # Job 1: Deploy Infrastructure and Application
  # ==========================================================================
  deploy:
    runs-on: ubuntu-latest
    outputs:
      deployed: ${{ steps.deploy.outcome == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .env file for Remote
        run: |
          echo "${{ secrets.ENV_FILE_PROD }}" > .env.production

      - name: Copy files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.KEY }}
          port: 22
          source: 'docker-compose.yml,nginx,apps/api/Dockerfile,apps/api/migration.Dockerfile,apps/api/drizzle,apps/api/package.json,apps/api/tsconfig.json,apps/api/src,packages/schemas,package.json,bun.lock,tsconfig.base.json,.env.production,scripts'
          target: '/home/${{ secrets.USERNAME }}/${{ env.COMPOSE_PROJECT_NAME }}'

      - name: Deploy on EC2
        id: deploy
        uses: appleboy/ssh-action@v1.0.3
        continue-on-error: false
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.KEY }}
          port: 22
          command_timeout: 10m
          script: |
            set -e  # Exit on any error

            cd /home/${{ secrets.USERNAME }}/${{ env.COMPOSE_PROJECT_NAME }}

            # Move the correct env file to .env
            mv .env.production .env

            # Export variables for docker-compose
            export APP_CONTAINER_NAME="${{ env.APP_CONTAINER_NAME }}"
            export DB_CONTAINER_NAME="${{ env.DB_CONTAINER_NAME }}"
            export REDIS_CONTAINER_NAME="${{ env.REDIS_CONTAINER_NAME }}"
            export NGINX_CONTAINER_NAME="${{ env.NGINX_CONTAINER_NAME }}"
            export DB_VOLUME_NAME="${{ env.DB_VOLUME_NAME }}"
            export REDIS_VOLUME_NAME="${{ env.REDIS_VOLUME_NAME }}"
            export NGINX_PORT="${{ env.NGINX_PORT }}"
            export APP_PORT="${{ env.APP_PORT }}"
            export COMPOSE_PROJECT_NAME="${{ env.COMPOSE_PROJECT_NAME }}"

            # Configuration
            MAX_RETRIES=3
            HEALTH_TIMEOUT=300  # 5 minutes
            POLL_INTERVAL=10    # 10 seconds

            echo "üöÄ Starting deployment..."

            # Gracefully stop existing containers
            echo "üì¶ Stopping existing containers..."

            # Check if any containers are running for this project
            EXISTING_CONTAINERS=$(docker compose ps -q 2>/dev/null | wc -l || echo "0")

            if [ "$EXISTING_CONTAINERS" -gt 0 ]; then
              echo "  Found $EXISTING_CONTAINERS running container(s), stopping..."
              
              # Attempt graceful shutdown with error capture
              DOWN_OUTPUT=$(docker compose down --remove-orphans 2>&1)
              DOWN_EXIT=$?
              
              if [ $DOWN_EXIT -ne 0 ]; then
                echo "‚ö†Ô∏è  Warning: docker compose down failed (exit code: $DOWN_EXIT)"
                echo "  Error output: $DOWN_OUTPUT"
                
                # Check for critical errors vs recoverable ones
                if echo "$DOWN_OUTPUT" | grep -qiE "(permission denied|daemon|socket)"; then
                  echo "‚ùå Critical Docker error detected. Cannot proceed."
                  exit 1
                fi
                
                # For non-critical errors (e.g., container already stopped), continue
                echo "  Attempting to force remove remaining containers..."
                docker compose rm -f -s 2>/dev/null || true
              else
                echo "  ‚úÖ Containers stopped successfully"
              fi
            else
              echo "  No existing containers found"
            fi

            # Build and start with retries
            echo "üî® Building and starting containers..."
            RETRY_COUNT=0
            DEPLOY_SUCCESS=false

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker compose up -d --build --remove-orphans 2>&1; then
                DEPLOY_SUCCESS=true
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                BACKOFF=$((RETRY_COUNT * 10))
                echo "‚ö†Ô∏è  Deploy attempt $RETRY_COUNT failed, retrying in ${BACKOFF}s..."
                sleep $BACKOFF
              fi
            done

            if [ "$DEPLOY_SUCCESS" != "true" ]; then
              echo "‚ùå Failed to start containers after $MAX_RETRIES attempts"
              docker compose logs --no-color --tail=100
              exit 1
            fi

            echo "‚è≥ Waiting for containers to become healthy..."

            # Wait for health checks with timeout
            ELAPSED=0
            ALL_HEALTHY=false

            while [ $ELAPSED -lt $HEALTH_TIMEOUT ]; do
              sleep $POLL_INTERVAL
              ELAPSED=$((ELAPSED + POLL_INTERVAL))
              
              # Get container health status
              HEALTH_STATUS=$(docker compose ps --format json 2>/dev/null | jq -r '.[].Health // "none"' 2>/dev/null || echo "unknown")
              RUNNING_COUNT=$(docker compose ps --format json 2>/dev/null | jq -r '.[].State' 2>/dev/null | grep -c "running" || echo "0")
              UNHEALTHY_COUNT=$(docker compose ps --format json 2>/dev/null | jq -r '.[].Health' 2>/dev/null | grep -c "unhealthy" || echo "0")
              
              echo "  ‚è±Ô∏è  ${ELAPSED}s - Running: $RUNNING_COUNT, Unhealthy: $UNHEALTHY_COUNT"
              
              # Check if any container is unhealthy
              if [ "$UNHEALTHY_COUNT" -gt 0 ]; then
                echo "‚ùå Unhealthy container detected!"
                docker compose ps
                docker compose logs --no-color --tail=50
                exit 1
              fi
              
              # Check if all expected services are running and healthy
              EXPECTED_SERVICES=$(docker compose config --services 2>/dev/null | wc -l | tr -d ' ')
              EXPECTED_SERVICES=${EXPECTED_SERVICES:-4}  # Fallback to 4 if command fails
              HEALTHY_COUNT=$(docker compose ps --format json 2>/dev/null | jq -r '.[].Health' 2>/dev/null | grep -c "healthy" || echo "0")
              
              # Services without healthcheck show as empty/none, count running as success for those
              TOTAL_OK=$((HEALTHY_COUNT + $(docker compose ps --format json 2>/dev/null | jq -r 'select(.Health == "" or .Health == null) | .State' 2>/dev/null | grep -c "running" || echo "0")))
              
              if [ "$RUNNING_COUNT" -ge "$EXPECTED_SERVICES" ]; then
                # All services running, check if health checks pass
                STARTING_COUNT=$(docker compose ps --format json 2>/dev/null | jq -r '.[].Health' 2>/dev/null | grep -c "starting" || echo "0")
                if [ "$STARTING_COUNT" -eq 0 ]; then
                  ALL_HEALTHY=true
                  break
                fi
              fi
            done

            # Final status check
            echo ""
            echo "üìä Final container status:"
            docker compose ps

            if [ "$ALL_HEALTHY" != "true" ]; then
              echo ""
              echo "‚ùå Containers did not become healthy within ${HEALTH_TIMEOUT}s"
              echo ""
              echo "üìã Container logs:"
              docker compose logs --no-color --tail=100
              exit 1
            fi

            echo ""
            echo "‚úÖ Deployment successful! All containers are running and healthy."

  # ==========================================================================
  # Job 2: Run Database Migrations
  # ==========================================================================
  migrate:
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Run Database Migrations
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.KEY }}
          port: 22
          command_timeout: 5m
          script: |
            set -e

            cd /home/${{ secrets.USERNAME }}/${{ env.COMPOSE_PROJECT_NAME }}

            echo "üóÑÔ∏è  Running database migrations..."

            # Source environment variables from .env file
            set -a
            source .env
            set +a

            # Wait for database to be fully ready
            echo "‚è≥ Waiting for database to be ready..."
            MAX_WAIT=60
            WAITED=0
            while [ $WAITED -lt $MAX_WAIT ]; do
              if docker exec ${{ env.DB_CONTAINER_NAME }} pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} 2>/dev/null; then
                echo "‚úÖ Database is ready"
                break
              fi
              sleep 2
              WAITED=$((WAITED + 2))
              echo "  Waiting... ${WAITED}s"
            done

            if [ $WAITED -ge $MAX_WAIT ]; then
              echo "‚ùå Database not ready after ${MAX_WAIT}s"
              exit 1
            fi

            # Run migrations using the dedicated migrate service
            echo "üìù Building and running migrations..."

            # Run migrations as a one-off task (--rm removes the container after exit)
            if docker compose --profile migrate run --rm --build migrate 2>&1; then
              echo "‚úÖ Migrations applied successfully!"
            else
              echo "‚ö†Ô∏è  Migration via docker compose failed, trying SQL files directly..."
              
              # Fallback: Apply SQL files directly in order
              MIGRATION_FAILED=false
              FAILED_FILES=""
              
              for sql_file in apps/api/drizzle/*.sql; do
                # Skip if no files match the glob (nullglob behavior)
                [ -e "$sql_file" ] || continue
                
                echo "Applying $sql_file..."
                if ! docker exec ${{ env.DB_CONTAINER_NAME }} psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -f "/dev/stdin" < "$sql_file"; then
                  echo "‚ùå Failed to apply: $sql_file"
                  MIGRATION_FAILED=true
                  FAILED_FILES="$FAILED_FILES $sql_file"
                else
                  echo "‚úÖ Applied: $sql_file"
                fi
              done
              
              if [ "$MIGRATION_FAILED" = "true" ]; then
                echo ""
                echo "‚ùå SQL Migration FAILED!"
                echo "Failed files:$FAILED_FILES"
                echo ""
                echo "Please check the database logs and fix the failing migrations."
                exit 1
              fi
            fi

            # Clean up migration container
            docker compose --profile migrate rm -f migrate 2>/dev/null || true

            echo ""
            echo "‚úÖ Database migrations completed!"

  # ==========================================================================
  # Job 3: Verify Deployment
  # ==========================================================================
  verify:
    runs-on: ubuntu-latest
    needs: migrate
    steps:
      - name: Verify Deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.KEY }}
          port: 22
          command_timeout: 2m
          script: |
            set -e

            cd /home/${{ secrets.USERNAME }}/${{ env.COMPOSE_PROJECT_NAME }}

            echo "üîç Verifying deployment..."

            # Check container status
            echo ""
            echo "üìä Container Status:"
            docker compose ps

            # Test API health endpoint
            echo ""
            echo "üè• Health Check:"

            # Wait a moment for things to stabilize
            sleep 5

            # Check via nginx - fail the job if health checks don't pass
            HEALTH_CHECK_PASSED=false

            if docker exec ${{ env.NGINX_CONTAINER_NAME }} wget -qO- http://localhost/health 2>/dev/null; then
              echo "‚úÖ Health check passed: http://localhost/health"
              HEALTH_CHECK_PASSED=true
            elif docker exec ${{ env.NGINX_CONTAINER_NAME }} wget -qO- http://app:3000/ 2>/dev/null; then
              echo "‚úÖ Health check passed: http://app:3000/"
              HEALTH_CHECK_PASSED=true
            fi

            if [ "$HEALTH_CHECK_PASSED" != "true" ]; then
              echo "‚ùå Health check FAILED!"
              echo ""
              echo "Container: ${{ env.NGINX_CONTAINER_NAME }}"
              echo "Attempted checks:"
              echo "  1. wget http://localhost/health - FAILED"
              echo "  2. wget http://app:3000/ - FAILED"
              echo ""
              echo "Please check container logs:"
              echo "  docker compose logs app"
              echo "  docker compose logs nginx"
              exit 1
            fi

            # Check database tables
            echo ""
            echo "üìã Database Tables:"
            source .env
            docker exec ${{ env.DB_CONTAINER_NAME }} psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "\dt" 2>/dev/null || echo "Could not list tables"

            echo ""
            echo "‚úÖ Deployment verification complete!"
